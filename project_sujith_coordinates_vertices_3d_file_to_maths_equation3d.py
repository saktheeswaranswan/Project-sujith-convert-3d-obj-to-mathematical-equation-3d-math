# -*- coding: utf-8 -*-
"""project-sujith coordinates vertices-3d-file-to-maths-equation3d.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vVPqgZVcUq0cUyh6Oc1p9bVQY5_mNp9S
"""

import csv
import math

# Function to read OBJ file and extract vertices
def read_obj(file_path):
    vertices = []
    with open(file_path, 'r') as file:
        for line in file:
            if line.startswith("v "):
                parts = line.split()
                x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
                vertices.append((x, y, z))
    return vertices

# Function to calculate distance based on provided formula
def calculate_distance(x, y, z, x1, y1, z1):
    return (x - x1) ** 2 + (y - y1) ** 2 + (z - z1) ** 2

# Main function to process the OBJ file
def process_obj(file_path):
    vertices = read_obj(file_path)

    if not vertices:
        print("No vertices found in the OBJ file.")
        return

    # Example center point (x1, y1, z1) can be set as the first vertex
    x1, y1, z1 = vertices[0]

    distances = []
    max_distance = float('-inf')

    # Calculate distances for all vertices
    for x, y, z in vertices:
        distance = calculate_distance(x, y, z, x1, y1, z1)
        distances.append((x, y, z, distance))
        max_distance = max(max_distance, distance)

    # Calculate R based on the maximum distance
    R = math.sqrt(max_distance)  # You can adjust this calculation if needed

    # Prepare CSV data
    csv_filename = 'vertices.csv'
    with open(csv_filename, 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['x', 'y', 'z'])
        csv_writer.writerows((x, y, z) for x, y, z in vertices)

    # Generate wxMaxima format output
    maxima_output = f"R : {R};\n"
    maxima_output += "vertices : [\n"
    for x, y, z in vertices:
        maxima_output += f"  [{x}, {y}, {z}],\n"
    maxima_output += "];"

    # Print or save the wxMaxima output
    print(maxima_output)

# Specify the path to your OBJ file
obj_file_path = '/content/baby.obj'
process_obj(obj_file_path)

import csv
import math
import os
import zipfile

# Function to read OBJ file and extract vertices
def read_obj(file_path):
    vertices = []
    with open(file_path, 'r') as file:
        for line in file:
            if line.startswith("v "):
                parts = line.split()
                x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
                vertices.append((x, y, z))
    return vertices

# Function to calculate distance based on provided formula
def calculate_distance(x, y, z, x1, y1, z1):
    return (x - x1) ** 2 + (y - y1) ** 2 + (z - z1) ** 2

# Function to generate cross-section data and save to CSV
def generate_cross_sections(vertices, output_dir):
    # X-Y Cross-section with Z fixed (taking the first Z)
    z_fixed = vertices[0][2]
    xy_cross = [(x, y) for x, y, z in vertices if z == z_fixed]

    with open(os.path.join(output_dir, 'xy_cross_section.csv'), 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['x', 'y'])
        csv_writer.writerows(xy_cross)

    # X-Z Cross-section with Y fixed (taking the first Y)
    y_fixed = vertices[0][1]
    xz_cross = [(x, z) for x, y, z in vertices if y == y_fixed]

    with open(os.path.join(output_dir, 'xz_cross_section.csv'), 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['x', 'z'])
        csv_writer.writerows(xz_cross)

    # Y-Z Cross-section with X fixed (taking the first X)
    x_fixed = vertices[0][0]
    yz_cross = [(y, z) for x, y, z in vertices if x == x_fixed]

    with open(os.path.join(output_dir, 'yz_cross_section.csv'), 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['y', 'z'])
        csv_writer.writerows(yz_cross)

# Main function to process the OBJ file
def process_obj(file_path):
    vertices = read_obj(file_path)

    if not vertices:
        print("No vertices found in the OBJ file.")
        return

    # Example center point (x1, y1, z1) can be set as the first vertex
    x1, y1, z1 = vertices[0]

    distances = []
    max_distance = float('-inf')

    # Calculate distances for all vertices
    for x, y, z in vertices:
        distance = calculate_distance(x, y, z, x1, y1, z1)
        distances.append((x, y, z, distance))
        max_distance = max(max_distance, distance)

    # Calculate R based on the maximum distance
    R = math.sqrt(max_distance)

    # Prepare output directory
    output_dir = 'output_data'
    os.makedirs(output_dir, exist_ok=True)

    # Generate cross sections
    generate_cross_sections(vertices, output_dir)

    # Prepare CSV for vertices
    csv_filename = os.path.join(output_dir, 'vertices.csv')
    with open(csv_filename, 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['x', 'y', 'z'])
        csv_writer.writerows((x, y, z) for x, y, z in vertices)

    # Generate wxMaxima format output
    maxima_output = f"R : {R};\n"
    maxima_output += "vertices : [\n"
    for x, y, z in vertices:
        maxima_output += f"  [{x}, {y}, {z}],\n"
    maxima_output += "];"

    # Print or save the wxMaxima output
    print(maxima_output)

    # Zip the output files
    zip_filename = 'output_data.zip'
    with zipfile.ZipFile(zip_filename, 'w') as zipf:
        for root, _, files in os.walk(output_dir):
            for file in files:
                zipf.write(os.path.join(root, file), file)

# Specify the path to your OBJ file
obj_file_path = 'baby.obj'
process_obj(obj_file_path)

import csv
import math
import os
import zipfile

# Function to read OBJ file and extract vertices
def read_obj(file_path):
    vertices = []
    with open(file_path, 'r') as file:
        for line in file:
            if line.startswith("v "):
                parts = line.split()
                x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
                vertices.append((x, y, z))
    return vertices

# Function to calculate distance based on provided formula
def calculate_distance(x, y, z, x1, y1, z1):
    return (x - x1) ** 2 + (y - y1) ** 2 + (z - z1) ** 2

# Function to generate cross-section contour data and save to CSV
def generate_cross_sections(vertices, output_dir):
    # Find unique Z levels for X-Y contour
    xy_contours = {}
    for x, y, z in vertices:
        if z not in xy_contours:
            xy_contours[z] = []
        xy_contours[z].append((x, y))

    # Save X-Y contours
    for z_level, points in xy_contours.items():
        with open(os.path.join(output_dir, f'xy_contour_z_{z_level:.2f}.csv'), 'w', newline='') as csvfile:
            csv_writer = csv.writer(csvfile)
            csv_writer.writerow(['x', 'y'])
            csv_writer.writerows(points)

    # Find unique Y levels for X-Z contour
    xz_contours = {}
    for x, y, z in vertices:
        if y not in xz_contours:
            xz_contours[y] = []
        xz_contours[y].append((x, z))

    # Save X-Z contours
    for y_level, points in xz_contours.items():
        with open(os.path.join(output_dir, f'xz_contour_y_{y_level:.2f}.csv'), 'w', newline='') as csvfile:
            csv_writer = csv.writer(csvfile)
            csv_writer.writerow(['x', 'z'])
            csv_writer.writerows(points)

    # Find unique X levels for Y-Z contour
    yz_contours = {}
    for x, y, z in vertices:
        if x not in yz_contours:
            yz_contours[x] = []
        yz_contours[x].append((y, z))

    # Save Y-Z contours
    for x_level, points in yz_contours.items():
        with open(os.path.join(output_dir, f'yz_contour_x_{x_level:.2f}.csv'), 'w', newline='') as csvfile:
            csv_writer = csv.writer(csvfile)
            csv_writer.writerow(['y', 'z'])
            csv_writer.writerows(points)

# Main function to process the OBJ file
def process_obj(file_path):
    vertices = read_obj(file_path)

    if not vertices:
        print("No vertices found in the OBJ file.")
        return

    # Example center point (x1, y1, z1) can be set as the first vertex
    x1, y1, z1 = vertices[0]

    distances = []
    max_distance = float('-inf')

    # Calculate distances for all vertices
    for x, y, z in vertices:
        distance = calculate_distance(x, y, z, x1, y1, z1)
        distances.append((x, y, z, distance))
        max_distance = max(max_distance, distance)

    # Calculate R based on the maximum distance
    R = math.sqrt(max_distance)

    # Prepare output directory
    output_dir = 'output_data'
    os.makedirs(output_dir, exist_ok=True)

    # Generate cross sections
    generate_cross_sections(vertices, output_dir)

    # Prepare CSV for vertices
    csv_filename = os.path.join(output_dir, 'vertices.csv')
    with open(csv_filename, 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['x', 'y', 'z'])
        csv_writer.writerows((x, y, z) for x, y, z in vertices)

    # Generate wxMaxima format output
    maxima_output = f"R : {R};\n"
    maxima_output += "vertices : [\n"
    for x, y, z in vertices:
        maxima_output += f"  [{x}, {y}, {z}],\n"
    maxima_output += "];"

    # Print or save the wxMaxima output
    print(maxima_output)

    # Zip the output files
    zip_filename = 'output_data.zip'
    with zipfile.ZipFile(zip_filename, 'w') as zipf:
        for root, _, files in os.walk(output_dir):
            for file in files:
                zipf.write(os.path.join(root, file), file)

# Specify the path to your OBJ file
obj_file_path = 'baby.obj'
process_obj(obj_file_path)

import csv
import math
import os
import zipfile

# Function to read OBJ file and extract vertices
def read_obj(file_path):
    vertices = []
    with open(file_path, 'r') as file:
        for line in file:
            if line.startswith("v "):
                parts = line.split()
                x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
                vertices.append((x, y, z))
    return vertices

# Function to calculate distance based on provided formula
def calculate_distance(x, y, z, x1, y1, z1):
    return (x - x1) ** 2 + (y - y1) ** 2 + (z - z1) ** 2

# Function to generate cross-section contour data and save to CSV
def generate_cross_sections(vertices, output_dir):
    # Collect contour points for each Z level for X-Y cross-section
    xy_contours = {}
    for x, y, z in vertices:
        if z not in xy_contours:
            xy_contours[z] = []
        xy_contours[z].append((x, y))

    # Write X-Y contours to CSV
    with open(os.path.join(output_dir, 'xy_contours.csv'), 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        header = ['z_level', 'x', 'y']
        csv_writer.writerow(header)
        for z_level, points in xy_contours.items():
            for x, y in points:
                csv_writer.writerow([z_level, x, y])

    # Collect contour points for each Y level for X-Z cross-section
    xz_contours = {}
    for x, y, z in vertices:
        if y not in xz_contours:
            xz_contours[y] = []
        xz_contours[y].append((x, z))

    # Write X-Z contours to CSV
    with open(os.path.join(output_dir, 'xz_contours.csv'), 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        header = ['y_level', 'x', 'z']
        csv_writer.writerow(header)
        for y_level, points in xz_contours.items():
            for x, z in points:
                csv_writer.writerow([y_level, x, z])

    # Collect contour points for each X level for Y-Z cross-section
    yz_contours = {}
    for x, y, z in vertices:
        if x not in yz_contours:
            yz_contours[x] = []
        yz_contours[x].append((y, z))

    # Write Y-Z contours to CSV
    with open(os.path.join(output_dir, 'yz_contours.csv'), 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        header = ['x_level', 'y', 'z']
        csv_writer.writerow(header)
        for x_level, points in yz_contours.items():
            for y, z in points:
                csv_writer.writerow([x_level, y, z])

# Main function to process the OBJ file
def process_obj(file_path):
    vertices = read_obj(file_path)

    if not vertices:
        print("No vertices found in the OBJ file.")
        return

    # Example center point (x1, y1, z1) can be set as the first vertex
    x1, y1, z1 = vertices[0]

    distances = []
    max_distance = float('-inf')

    # Calculate distances for all vertices
    for x, y, z in vertices:
        distance = calculate_distance(x, y, z, x1, y1, z1)
        distances.append((x, y, z, distance))
        max_distance = max(max_distance, distance)

    # Calculate R based on the maximum distance
    R = math.sqrt(max_distance)

    # Prepare output directory
    output_dir = 'output_data'
    os.makedirs(output_dir, exist_ok=True)

    # Generate cross sections
    generate_cross_sections(vertices, output_dir)

    # Prepare CSV for vertices
    csv_filename = os.path.join(output_dir, 'vertices.csv')
    with open(csv_filename, 'w', newline='') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['x', 'y', 'z'])
        csv_writer.writerows((x, y, z) for x, y, z in vertices)

    # Generate wxMaxima format output
    maxima_output = f"R : {R};\n"
    maxima_output += "vertices : [\n"
    for x, y, z in vertices:
        maxima_output += f"  [{x}, {y}, {z}],\n"
    maxima_output += "];"

    # Print or save the wxMaxima output
    print(maxima_output)

    # Zip the output files
    zip_filename = 'output_data.zip'
    with zipfile.ZipFile(zip_filename, 'w') as zipf:
        for root, _, files in os.walk(output_dir):
            for file in files:
                zipf.write(os.path.join(root, file), file)

# Specify the path to your OBJ file
obj_file_path = 'baby.obj'
process_obj(obj_file_path)

import csv
import os

def merge_cross_sections(output_dir):
    # Prepare output file
    merged_filename = os.path.join(output_dir, 'merged_cross_sections.csv')

    with open(merged_filename, 'w', newline='') as merged_file:
        csv_writer = csv.writer(merged_file)
        # Write header
        csv_writer.writerow(['cross_section_type', 'fixed_value', 'x', 'y', 'z'])

        # Merge X-Y contours
        xy_file = os.path.join(output_dir, 'xy_contours.csv')
        with open(xy_file, 'r') as xy_csv:
            reader = csv.reader(xy_csv)
            next(reader)  # Skip header
            for row in reader:
                z_level, x, y = row
                csv_writer.writerow(['XY', z_level, x, y, ''])

        # Merge X-Z contours
        xz_file = os.path.join(output_dir, 'xz_contours.csv')
        with open(xz_file, 'r') as xz_csv:
            reader = csv.reader(xz_csv)
            next(reader)  # Skip header
            for row in reader:
                y_level, x, z = row
                csv_writer.writerow(['XZ', y_level, x, '', z])

        # Merge Y-Z contours
        yz_file = os.path.join(output_dir, 'yz_contours.csv')
        with open(yz_file, 'r') as yz_csv:
            reader = csv.reader(yz_csv)
            next(reader)  # Skip header
            for row in reader:
                x_level, y, z = row
                csv_writer.writerow(['YZ', x_level, '', y, z])

    print(f"Merged cross sections saved to {merged_filename}")

# Specify the output directory where the individual CSVs are located
output_dir = 'output_data'
merge_cross_sections(output_dir)